## 垃圾回收算法

### 标记阶段

1. **引用计数法**
   - 对每个对象保存一个整型的引用计数器属性，记录对象被引用的情况
   - 优点：实现简单，判定效率高
   - 缺点：无法处理循环引用（内存泄漏）
2. **可达性分析法（根搜索法）**
   - 以GC ROOT（一组必须活跃的引用）为起始点，从上至下搜索被根对象集合所连接的目标对象是否可达。搜索过的路径为引用链（Reference Chain）
   - GC ROOT包括：
     - 虚拟机栈中引用的对象（局部变量）
     - 本地方法栈内引用的对象
     - 方法区中类静态属性引用的对象
     - 方法区中常量引用的对象
     - 被同步锁Synchronized持有的对象
     - JVM内部的引用（基本数据类型的Class对象、常驻的异常对象、系统类加载器）

### 清除阶段

1. **标记——清除法（Mark——Sweep）**
   - 标记：从根开始标记被引用的对象
   - 清除：线性遍历所有对象，回收未标记对象
   - 缺点：效率不高；GC时停止程序，用户体验差；产生内部碎片，需维护一个空闲列表
2. **复制算法（Copying）**
   - 将内存空间分为两块，每次只使用一块，GC是将正在使用内存中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象
   - 优点：高效；无碎片问题
   - 缺点：需要两倍存储空间；需要维护对象的引用关系
3. **标记——压缩（Mark——Compact）**
   - 标记：
   - 压缩：将所有存活的对象压缩到内存的一端，按顺序排放
   - 清除：清理边界外所有的空间
   - 缺点：效率低；暂停程序；修改引用

### 其他

1. 分代收集法

   不同生命周期的对象采取不同的收集方式

2. 增量收集法

   - 解决STW。每次GC一小片区域，让GC线程和应用程序线程交替执行
   - 缺点：线程切换和上下文切换消耗，GC成本上升，吞吐量下降

3. 分区算法

## 垃圾回收器

### 串行GC（Serial Garbage Collector）

### 并行GC（Parallel Garbage Collector）

### 并发标记扫描GC（Concurrent Mark Sweep，CMS）

### G1 GC





