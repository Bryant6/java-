# 序列化（创建可复用的java对象）

- **保存（持久化）对象及其状态到内存或者磁盘**：一般般情况下，只有当JVM 处于运行时， 这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中， 就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能。
- 序列化对象以**字节数组**保持---静态成员不保存
- 序列化用户远程对象传输
- 序列化及反序列化
  - Serializable实现序列化（实现java.io.Serializable）
  - ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化
  - 在类中增加writeObject和readObject方法实现自定义序列化策略
- **序列化ID**：是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个 类的序列化 ID 是否一致（就是 private static final long serialVersionUID）
- **Transient**关键字阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，int型为0，对象型为null

# 复制

- 直接赋值复制

  A a1 = a2，这实际上复制的是引用，也就是 说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟 着变化。

- 浅复制（复制引用但不复制引用的对象）

  创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的， 那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。 因此，原始对象及其副本引用同一个对象。 

- 深复制（复制引用及其对象）

**序列化实现深clone：**把对 象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。