# Runtime Data Area

## 程序计数器（PC寄存器）Program Counter Register

- 作用：存储下一条要执行的指令地址。CPU需要不停的切换线程，切换回来以后，就得知道从哪儿开始继续执行
- GC和OOM都不存在

## 虚拟机栈 Java Virtual Machine Stack

- 栈是运行时的单位，堆是存储的单位
- 一个栈帧对应一个java方法调用。线程私有同线程的生命周期一致
- 作用：主管java程序的运行，保存方法的局部变量、部分结果，并参与方法的调用和返回
- 不存在GC，存在OOM

## 本地方法栈 Native Method Stack

- 管理本地方法的调用
- 线程私有，无线程安全问题。存在OOM

## 堆 Heap

1. 一个JVM实例只存在一个堆内存；
2. 所有的对象实例和数组都应当在运行时分配到堆上；
3. 在方法结束后，堆中的对象不会马上被移除，在GC时才被移除
4. 堆的内初细分：（优化GC性能；对象的生命周期不同）
   - java7以前：新生区（Eden、Survivor0、survivor1）+ 养老区 + 永久区
   - java8以后：新生区（Eden、Survivor0、survivor1） + 养老区 + 元空间
5. 对象分配过程：
   1. new的对象先放在伊甸园区。有大小限制；
   2. 当伊甸园区满，程序又要new对象时，JVM的垃圾回收器对Eden区进行垃圾回收（Minor GC），将Eden区不被引用的对象销毁，再加载新的对象到Eden区；
   3. 然后将Eden区中的剩余对象移动到S0区；
   4. 如果再次触发Minor GC，此时S0区的如果没有回收，就转移到S1区；再次GC（S1-> S0）；
   5. 可以设置次数--XX：MaxTenuringThreshold = <N>,默认为15次，进去养老区；
   6. 当养老区内存不足时，触发GC（Major GC），对养老区内存清理；
   7. 若养老区执行完GC依然无法保存对象，就会产生OOM。
6. 内存分配策略（对象提升（Promotion）规则）：
   - 优先分配到Eden区
   - 大对象直接分配到养老区
   - 长期存活的对象分配到养老区
   - 动态对象年龄判断
   - 空间分配担保

## 方法区（元空间）（Method Area（Metaspace））

- 各线程共享的内存区域
- JVM启动时创建，JVM关闭时释放这个空间的内存区域
- 存储内容：类型信息、运行时常量池、静态变量、JIT（即时编译器）代码缓存、域信息、方法信息
- 空间的大小可以选择固定大小或者可扩展，方法区的大小决定了系统可以保存多少个类，定义的类太多会导致方法区溢出（OOM）：
  - 加载大量的第三方jar包
  - Tomcat部署的工程太多
  - 大量动态生成反射类

